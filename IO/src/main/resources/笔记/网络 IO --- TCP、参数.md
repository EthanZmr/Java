# 网络 IO --- TCP、参数

> CLI_NO_DELAY 	缓冲优化 默认为false, 表示使用缓冲区进行发送
>
> BACK_LOG 		   允许几个后备连接等待
>
> CLI_KEEPALIVE	 长连接
>
> SO_TIMEOUT		accept()超时时间
>
> CLI_OBB				客户端传输数据的时候会先发送一个字节过去，再将后面数据的批量发送

服务端会开启 listen 状态申请给定的端口号,并创建一个文件描述符映射到 listen, 所有客户端通信的时候分为两个阶段, 三次握手的时候走 listen 这个进程, 三次握手完成之后会分配一个文件描述符交给一个线程(进程), 发送数据的时候就会使用后面分配的这个 fd。

在 server 没有进行 accept 之前，如果有客户端连接到server，在kernel 中已经和客户端建立了socket连接, 但这个连接还没有分配给一个应用程序进行使用。

这时候客户端如果发送数据给服务器, 此时 kernel 会有一个缓冲区(RECV-Q、 SEND-Q)进行接收客户端发送过来的数据缓冲。

服务端的accept() 方法执行会拿到 kernel 分配的用于进行数据传输的 fd并将 fd 抽象成 socket 对象，并且会收到 kernel 中缓存的客户端数据，并且会将 socket 连接分配给应用程序。

TCP：面向连接的可靠的传输协议, 三次握手之后, 客户端和服务器都会在内核开辟连接资源。

socket 具体可以理解为一个四元组：客户端 IP + 客户端 PORT + 服务端 IP + 服务端 PORT

客户端访问服务端，会随机申请一个端口号, client 和 server 建立连接后会得到一个 socket 四元组,这个 socket 四元组具有唯一性。

只要 socket 四元组中任意一个参数改变，就是一个不同的连接, 所以一台服务器理论上可以建立远远超过 65535 个连接。(端口号是两个字节大小)

不同的进程中, fd 是可以重复的。因为进程是隔离的, 但是同一个进程中 fd 是唯一的。

程序读写操作都是操作kernel 中分配的 fd，这个 fd 是 socket 连接的一个映射。连接建立之后client 和 server就会申请缓冲区 RECV-Q、 SEND-Q。

`netstat -natp` 查看socket连接状态、 socket 缓冲区(RECV-Q、SEND-Q)、连接分配给了哪个应用程序

如果连接数超过了BACK_LOG设置的大小, 新建的连接将处于 SYNC_RECV 状态, 即服务端收到了第一次握手请求，但是没有给客户端响应。如果 SYNC_RECV状态持续时间超过一定的时间，就会丢弃这个连接。

系统数据包大小：ifconfig--->mtu

抓包的数据中：options--->mss 差不多是真实数据大小

数据量很大时, 会切成很多的数据包往外发, 三次握手的时候会协商一个窗口大小, 传输数据的时候也会动态调整窗口大小。

TCP 拥塞：如果窗口被填满了, 服务端返回的 ack 中会告诉客户端窗口没有余量了，客户端先阻塞住不要发了，等数据处理完了, 窗口余量足够之后再通知客户端重新发送, 如果窗口满了还继续发，满了之后的数据会被丢弃。

在 client 设置了 sendbuffer 之后，如果每次读一行，那么一次发送的大小可以大于设置的 buffer 大小。

```java
client.setSendBuffer(20);
sc.readLine();
```

只要没遇到换行符就可以一直写下去，发送的时候就可以超过 20 的大小。

`keepAlive` TCP 中如果双方建立了连接, 如果很久都不交互, 无法确定对方是否还在线，所以有了 keepAlive。会周期发送心跳检测, 超过一定时间没有回应就会将该连接踢掉。

## BIO 同步阻塞

> 同步、异步、阻塞、非阻塞

`strace -ff -o out cmd`命令追踪kernel系统调用

 `new ServerSocket(8090)` 在kernel 中调用了socket系统调用创建 socket 并返回一个文件描述符fd, 然后调用 bind(fd, 8090)将 8090与 fd 绑定, 然后调用listen(fd, ...)监听 fd 有没有连接进来。

上面三个系统调用完成后, 使用命令`netstat -natp`可以看到创建LISTEN 状态的监听条目

在应用程序中调用 accept() 时会相应的进行系统调用accept(fd, ...);进行阻塞。

在 Java 中创建一个线程时在 kernel 中相应的会进行 clone 系统调用创建一个子进程。 clone 出的子进程可以共享调用进程(一般指父进程)的上下文，例如虚拟地址空间, 文件描述符表, 信号处理器表。











