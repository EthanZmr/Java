### 进程
面试题：进程和线程有什么区别?

普通回答: 进程就是一个程序运行起来的状态, 线程是一个进程中的不同的执行路径.

专业回答: 进程是操作系统用来分配资源的基本单位, 线程是操作系统用来执行调度的基本单位.分配的资源最重要的是: 独立的内存地址空间, 线程调度执行.(线程共享进程的内存空间, 没有独立的内存空间)

```
linux中也称为task, 是系统分配资源的基本单位
资源：独立的地址空间 内核数据结构(进程描述符...) 全局变量 数据段...
进程描述符: PCB (Process Control Block)
```

### 线程
在 linux 中的实现: 就是一个普通进程, 只不过和其他进程共享资源(内存空间、全局数据等)

其他系统都有各自的所谓LWP的实现(Light Weight Process)

高层面理解: 一个进程中不同的执行路线.

### 纤程
轻量级线程, 在用户态创建并进行管理,无需切换内核态.
可以理解为线程中的线程...切换和调度无需经过操作系统。

优势: 
1. 占用资源很少, 操作系统线程基本空间为 1MB, 纤程基本空间 4K
2. 切换简单, 无需经过内核态
3. 启动很多个纤程没有问题

应用场景：很短的计算任务,不需要和内核打交道

##### 内核线程
内核启动之后经常需要做一些后台操作, 这些由Kernel Thread来完成.

只在内核空间运行

##### 进程创建和启动
系统调用fork() exec()
从A中fork B的话, A称之为B的父进程
fork()内部调用 clone()来创建进程.

##### 僵尸进程
子进程已经结束了但是 PCB 没有释放掉

##### 孤儿进程
父进程结束了但子进程还没有结束, 操作系统会自动换一个父进程.

### 进程调度
内核进程调度器决定: 该哪个进程运行? 何时开始? 运行多长时间?

每一个进程都可以有自己定制的进程调度方案

单任务到多任务：最大限度压榨 CPU 资源

##### 多任务
* 非抢占式：除非进程主动让出 CPU, 否则将一直运行
* 抢占式：由进程调度器强制开始或暂停(抢占)某一进程的执行

2.6 开始采用 CFS 调度策略: Completely Fair Scheduler

按优先级分配时间片的比例, 记录每个进程的执行时间, 如果有一个进程执行时间不到他应该分配的比例, 优先执行该进程.

##### 进程调度基本概念
* 进程类型
    * IO 密集型 大部分时间用于等待 IO
    * CPU 密集型 大部分时间用于闷头计算
* 进程优先级
    * 实时进程 > 普通进程(0 - 99)
    * 普通进程 nice 值(-20 - 19)
* 时间分配
    * linux采用按优先级的 CPU 时间片
    * 其他系统多采用按优先级的时间片

##### Linux 默认的调度策略
对于实时进程: 使用SCHED_FIFO和SCHED_RR两种
对于普通进程: 使用CFS

其中登记最高的是FIFO, 这种进程除非自己让出CPU否则Linux会一直执行它除非更高等级的FIFO和RR抢占它

RR只是这种线程中是同级别FIFO中的平均分配

只有实时进程主动让出, 或者执行完毕后, 普通进程才有机会运行.

### 中断

int 0x80 软中断类型

int: interrupt
0x80: 十六进制数

系统调用: int 0x80或者sysenter原语, 通过ax寄存器填入调用号

参数通过bx cx dx si di传入内核 返回值通过 ax 返回

Java 读网络 -> jvm read() -> c库 read() -> 内核空间 -> system_call() (系统调用处理程序) -> sys_read()

**用户态与内核态的切换, 涉及到系统调用. 效率相对低.**
