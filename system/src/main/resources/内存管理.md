# 内存管理

现代内存管理系统：虚拟内存、分页装入、软硬件结合寻址

1. 分页(内存不够用), 内存中分成固定大小的页框(4k), 把程序(硬盘上)分成4K大小的块, 用到哪一块, 加载哪一块,
加载的过程中如果内存满了, 会把最不常用的一块放到swap分区, 把最新的一块加载进来, 这个就是LRU算法.
   1. LRU算法LeetCode146题
   2. Least Recently Used 最不常用
   3. 哈希表(保证查找操作O(1)) + 链表(保证排序操作和新增操作O(1))
   4. 双向链表(保证左边指针指向右边内存块)
2. 虚拟内存(解决内存访问相互打扰问题)
   1. 为了保证互不影响, 让进程工作在虚拟空间, 程序中用到的空间地址不再是直接的物理地址, 而是虚拟的地址,这样A进程永远不可能访问到B进程的空间
   2. 虚拟空间地址为内存的寻址空间---> 64位系统为2^64(byte)
   3. 从进程的角度来看, 它自己独享整个内存和CPU资源
3. 为什么使用虚拟内存
   * 隔离应用程序：每个程序都认为自己有连续可用的内存, 突破物理内存限制, 应用程序无需考虑物理内存是否够用, 是否能够分配等底层问题
   * 安全：保护物理内存, 不被恶意程序访问
   * 内存映射：偏移量 + 段的基地址 = 线性地址(虚拟空间)
   * 线性地址通过OS+MMU(memory map unit)
4. 缺页中断
   * 需要用到的页面内存中没有, 产生缺页异常(中断), 由内核处理并加载

CPU如何区分一个立即数和一条指令：
* 总线内部分为：数据总线、地址总线、控制总线
* 地址总线目前只支持48位

## 内核同步方法

1. 原子性,有序性,可见性
   1. 原子操作
   2. 自旋锁-内核中通过汇编支持的cas
   3. 读-写自旋-类似于readWriteLock,可同时读只能一个写
   4. 信号量-类似于Semaphore, 重量级锁, 线程会进入wait,适合长时间持有的锁情况
   5. 读-写信号量-downread upread downwrite upwrite(多个写, 可以分段写, 比较少用)
   6. 互斥体(mutex)-特殊的信号量(01二值信号量)
   7. 完成变量-vfork()在子进程结束时通过完成变量叫醒父进程
   8. BKL-大内核锁(早期, 现在已经不用)
   9. 顺序锁-线程可以挂起的读写自旋锁：序列计数器(从0开始, 写时增加(+1), 写完释放(+1), 读之前发现单数, 说明有写线程, 等待, 读前读后序列一样, 说明没有写线程打断.)
   10. 禁止抢占

